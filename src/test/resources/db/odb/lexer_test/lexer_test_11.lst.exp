00001  ; MacSHAPA Open Database
00002  ;
00003  ; This is a duplicate of lexer_test_03.txt, save with '\n' substituted for 
00004  ; '\r' throughout the file.  The purpose of the substitution is to verify that
00005  ; the Openshapa MacshapaODBReader class doesn't care whether new lines are marked
00006  ; with '\r' or '\n'.
00007  ; 
00008  ; This database starts to get rough with the lexer.  The general idea is to 
00009  ; generate all the errors and warnings that the lexer is capable of flagging.
00010  ;
00011  ; Needless to say, this is not a legal database, and will cause even more
00012  ; fireworks if fed to the parser instead of just the lexer.
00013  ;
00014  ; This file deals only with errors that can be generated with numeric tokens.
00015  ;
00016  ; This integer has too many digits:
00017  
00018          10000000000000000000000000000000000000000000000

      WARNING   6 (Line 18:9): Integer value out of range.  Coerced value to nearest legal value.


      ERROR  0 (Line 18:9): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 4(INT_TOK)) (aux = 0) (val = 2.147483647E9) (str = 2147483647) (line_number = 18) (line_index = 9))

forcing modbr.abort_scan back to false...

00019  
00020  ; and this is a negative integer with the same problem
00021  
00022  		-100000000000000000000000000000000000000000000000

      WARNING   6 (Line 22:3): Integer value out of range.  Coerced value to nearest legal value.


      ERROR  0 (Line 22:3): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 4(INT_TOK)) (aux = 0) (val = -2.147483648E9) (str = -2147483648) (line_number = 22) (line_index = 3))

forcing modbr.abort_scan back to false...

00023  
00024  ; This numeric token doesn't contain any digits:
00025  
00026  -.

      ERROR  5 (Line 26:1): Ill formed numerical constant.

Unable to continue parse -- Aborting...
((code = 0(ERROR_TOK)) (aux = 0) (val = 0.0) (str = -.) (line_number = 26) (line_index = 1))

forcing modbr.abort_scan back to false...

00027  
00028  ; This floating point value is too large (in terms of absolute value):
00029  
00030  -1000000000000000000000000000000000000000000000000000000000000000000.

      WARNING   7 (Line 30:1): Absolute value of floating point value too large.  Coerced value to nearest legal value.


      ERROR  0 (Line 30:1): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 5(FLOAT_TOK)) (aux = 0) (val = -4.40282E38) (str = -440282000000000000000000000000000000000.000000) (line_number = 30) (line_index = 1))

forcing modbr.abort_scan back to false...

00031  
00032  ; This floating point value is too small:
00033  
00034  0.000000000000000000000000000000000000000000000000000000000000000000000000000000001

      WARNING   8 (Line 34:1): Discarded one or more least significant digits from fractional part of floating point value.


      ERROR  0 (Line 34:1): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 5(FLOAT_TOK)) (aux = 0) (val = 0.0) (str = 0.000000) (line_number = 34) (line_index = 1))

forcing modbr.abort_scan back to false...

00035  
00036  ; This floating point value is both too large and contains too small a fraction
00037  
00038  100000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000001

      WARNING   7 (Line 38:1): Absolute value of floating point value too large.  Coerced value to nearest legal value.


      ERROR  0 (Line 38:1): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...

      WARNING   8 (Line 38:1): Discarded one or more least significant digits from fractional part of floating point value.


      ERROR  0 (Line 38:1): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 5(FLOAT_TOK)) (aux = 0) (val = 4.40282E38) (str = 440282000000000000000000000000000000000.000000) (line_number = 38) (line_index = 1))

forcing modbr.abort_scan back to false...

00039  
00040  ; This is an example of the lexer being a bit too kind about accepting numbers.
00041  ; This will be lexed as two floating point numbers;
00042  
00043  	1.1.1
((code = 5(FLOAT_TOK)) (aux = 0) (val = 1.1) (str = 1.1) (line_number = 43) (line_index = 2))

((code = 5(FLOAT_TOK)) (aux = 0) (val = 0.1) (str = .1) (line_number = 43) (line_index = 5))

00044  
00045  ; Finally, and end of file in a numeric token.  The lexer doesn't care about this,
00046  ; so it shouldn't generate an error
00047  
00048  
00049  9999999999

      WARNING   6 (Line 49:1): Integer value out of range.  Coerced value to nearest legal value.


      ERROR  0 (Line 49:1): Warning limit exceeded - load aborted.

Unable to continue parse -- Aborting...
((code = 4(INT_TOK)) (aux = 0) (val = 2.147483647E9) (str = 2147483647) (line_number = 49) (line_index = 1))

forcing modbr.abort_scan back to false...

((code = 13(EOF_TOK)) (aux = 0) (val = 0.0) (str = ) (line_number = 49) (line_index = 0))

