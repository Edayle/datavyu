package org.openshapa.views.component;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.GeneralPath;

import javax.swing.JComponent;

import org.openshapa.models.component.NeedleModel;
import org.openshapa.models.component.ViewableModel;

/**
 * This class paints a timing needle.
 */
public class NeedlePainter extends JComponent {

    /**
     * Auto generated by Eclipse
     */
    private static final long serialVersionUID = -6157748998316240030L;

    /** Polygon region for the needle marker */
    private GeneralPath needleMarker;

    private NeedleModel needleModel;
    private ViewableModel viewableModel;

    public NeedlePainter() {
        super();
    }

    public NeedleModel getNeedleModel() {
        return needleModel.clone();
    }

    public void setNeedleModel(final NeedleModel needleModel) {
        this.needleModel = needleModel;
        this.repaint();
    }

    public void setViewableModel(final ViewableModel viewableModel) {
        this.viewableModel = viewableModel;
        this.repaint();
    }

    @Override
    public synchronized boolean contains(final Point p) {
        return needleMarker.contains(p);
    }

    @Override
    public synchronized boolean contains(final int x, final int y) {
        return needleMarker.contains(x, y);
    }


    private final Color needleColor = new Color(250, 0, 0, 100); 

    @Override
    public synchronized void paint(final Graphics g) {
        if (needleModel == null || viewableModel == null) {
            return;
        }

        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        assert needleModel.getNeedleHeadWidth() > 0 && needleModel.getNeedleHeadHeight() > 0;
        final double needleHeadWidth = needleModel.getNeedleHeadWidth();
        final double needleHeadHeight = needleModel.getNeedleHeadHeight();
        
        final long currentTime = needleModel.getCurrentTime();
        // Don't paint if the needle if it is out of the current window
        if ((currentTime < viewableModel.getZoomWindowStart())
                || (viewableModel.getZoomWindowEnd() < currentTime)) {
            return;
        }

        Dimension size = this.getSize();

        // Calculate the needle position based on the selected time
        double ratio = (double) viewableModel.getIntervalWidth() / viewableModel.getIntervalTime();
        double pos = (currentTime * ratio - viewableModel.getZoomWindowStart() * ratio) + needleModel.getPaddingLeft();

        final int paddingTop = needleModel.getPaddingTop();
        needleMarker = new GeneralPath();
        needleMarker.moveTo((float) (pos - needleHeadWidth), (float) (paddingTop)); // top-left corner
        needleMarker.lineTo((float) (pos + needleHeadWidth), (float) (paddingTop)); // top-right corner
        needleMarker.lineTo((float) (pos),                   (float) (needleHeadHeight + paddingTop)); // bottom corner
        needleMarker.closePath();

        g2d.setColor(needleColor);
        g2d.fill(needleMarker);

        g2d.setColor(needleColor.darker());
        g2d.draw(needleMarker);

        // Draw the timing needle
        float x1 = (float) pos;
        float y1 = (float) (paddingTop + needleHeadHeight);
        float x2 = (float) pos;
        float y2 = (float) size.height;

        GeneralPath line = new GeneralPath();
        line.moveTo(x1, y1);
        line.lineTo(x2, y2);

        assert needleModel.getNeedleWidth() > 0;
        g2d.setStroke(new BasicStroke((float) needleModel.getNeedleWidth()));
        g2d.draw(line);
    }
}
