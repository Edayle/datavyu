package org.openshapa.views.component;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.GeneralPath;

import javax.swing.JComponent;

import org.openshapa.models.component.MixerView;
import org.openshapa.models.component.NeedleConstants;
import org.openshapa.models.component.NeedleModel;
import org.openshapa.models.component.Viewport;


/**
 * This class paints a timing needle.
 */
public final class NeedlePainter extends JComponent {

    /**
     * Auto generated by Eclipse
     */
    private static final long serialVersionUID = -6157748998316240030L;

    /** Polygon region for the needle marker */
    private GeneralPath needleMarker;

    private NeedleModel needleModel;
    private MixerView mixer;


    private final Color needleColor = new Color(250, 0, 0, 100);

    public NeedlePainter() {
        super();
    }

    public NeedleModel getNeedleModel() {
        return needleModel.copy();
    }

    public void setNeedleModel(final NeedleModel needleModel) {
        this.needleModel = needleModel;
        this.repaint();
    }

    public void setMixerView(final MixerView mixer) {
        this.mixer = mixer;
        repaint();
    }

    @Override public boolean contains(final Point p) {
        return (needleMarker != null) && needleMarker.contains(p);
    }

    @Override public boolean contains(final int x, final int y) {
        return (needleMarker != null) && needleMarker.contains(x, y);
    }

    @Override public void paintComponent(final Graphics g) {

        if ((needleModel == null) || (mixer == null)) {
            return;
        }

        Viewport viewport = mixer.getViewport();

        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON);

        assert (NeedleConstants.NEEDLE_HEAD_WIDTH > 0)
            && (NeedleConstants.NEEDLE_HEAD_HEIGHT > 0);

        final double needleHeadWidth = NeedleConstants.NEEDLE_HEAD_WIDTH;
        final double needleHeadHeight = NeedleConstants.NEEDLE_HEAD_HEIGHT;

        final long currentTime = needleModel.getCurrentTime();

        // Don't paint if the needle if it is out of the current window
        if (!viewport.isTimeInViewport(currentTime)) {
            return;
        }

        Dimension size = this.getSize();

        // Calculate the needle position based on the selected time
        double pos = viewport.computePixelXOffset(currentTime)
            + Math.ceil(needleHeadWidth);

        needleMarker = new GeneralPath();

        // top-left corner
        needleMarker.moveTo((float) (pos - needleHeadWidth), 0);

        // top-right corner
        needleMarker.lineTo((float) (pos + needleHeadWidth), 0);

        // bottom corner
        needleMarker.lineTo((float) pos, (float) needleHeadHeight);
        needleMarker.closePath();

        g2d.setColor(needleColor);
        g2d.fill(needleMarker);

        g2d.setColor(needleColor.darker());
        g2d.draw(needleMarker);

        // Draw the timing needle
        float x1 = (float) pos;
        float y1 = (float) needleHeadHeight;
        float x2 = (float) pos;
        float y2 = (float) size.height;

        GeneralPath line = new GeneralPath();
        line.moveTo(x1, y1);
        line.lineTo(x2, y2);

        assert NeedleConstants.NEEDLE_WIDTH > 0;
        g2d.setStroke(new BasicStroke((float) NeedleConstants.NEEDLE_WIDTH));
        g2d.draw(line);
    }
}
